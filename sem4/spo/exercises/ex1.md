# Exercise Session 1

## Exercise 1

1. Because different languages are suited to solve different problems.
2. Because it can optimize the problem solving. Some programming languages are better suited for certain programs.
3. Fortran
4. COBOL
5. Lisp
6. HTML
7. Because it is difficult to get even two computer scientists to agree on the value of some given language characteristic relative to the others.
8. It makes it easier to read.
9. because a single instruction can use either registers or memory cells as the operands.
10. too much freedom can lead to unnecessary complexity.
11. It is a measure of how easily a language can be used to create programs for a chosen problem domain. It is taken into consideration which languages you compare with. Fx C and visual basic is not a good comparison.
12. Because errors in programs can go undetected when nearly any combination of primitives is legal. This can lead to code absurdities that cannot be discovered by the computer.
13. the ```count++```in C vs the ```count = count + 1```.
14. Testing for type errors in a given program, either by the compiler or during program execution.
15. Fx in the use of subprogram parameters.
16. Program maintenance + programming it.
17. How easily  the programs can be moved from one implementation to another.
18. the completeness and precision of the languageâ€™s official defining document
19. Figure 1.1 page 42
20. Incompleteness of type checking and inadequacy of control statements.
21. data abstraction, inheritance and dynamic method binding.
22. Smalltalk.
23. writability and readability. fx pointers in c++
24. one: programs that are translated to machine language. Compiler implementation. C
    two: Pure interpretation, javascript
    three: Hybrid implementation systems, both compiled and interpreted. Java
25. Compiler
26. It serves as a database for the compilation process. The promary contents of the symbol table are the type and attribute information of each user-defined name in the program. (page 49)
27. It collects the system programs and links them to user programs.
28. because how the connection should also be taken into account on how the overall performance is. And the bottleneck should always be the focus.
29. Easy implementation of many source-level debugging operations, because all run-time error messages can refer to source-level units.
